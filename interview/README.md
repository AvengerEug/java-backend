## 一、java基础相关

### 1.1 聊聊jdk的集合

#### 1.1.1 ArrayList

* ArrayList底层是一个可扩展的数组，在内存中是一段连续的空间，所以查询效率比较快。当我们默认new一个ArrayList时，`默认的数组容量是10`，同时我们也能指定数组长度，但这只是定义了数组的一个长度，并不是它的实际长度。它的实际长度是由它内部一个叫size的属性维护的。在调用它的add方法时，首先会去判断容量是否足够，size + 1的长度大于数组的长度时，此时就会进行扩容，**扩容为原来的`1.5`倍**，然后把原来的数组copy过去。`arrayList添加元素至指定下标的add方法和remove方法都是通过移动数组的方式实现的`。当需要把某个元素插入到某个下标时，arrayList是将当前下标及其后面的所有元素都往后挪一个位置。就是将数组拷贝到index + 1的位置上。remove时也差不多，是将index + 1以及后面的所有元素copy成一个数组，然后把这个数组放在index的位置上，完成remove操作。
* 同时`ArrayList的迭代器是fast-fail`（见源码：java.util.AbstractList#modCount），当我们在使用迭代器遍历的过程中若直接对数组进行了remove操作，此时会抛出ConcurrentModifiedException，此时我们应该要使用`迭代器`来执行remove操作来避免此异常的发生。它是非线程安全的，所以在多线程中，我们可以选择**vector、Collections.synchronizedList()和juc包下的CopyOnWriteArrayList**; 前两者差距都差不多，都是在方法处添加了synchronized关键字保证同步，而juc下的CopyOnWriteArrayList保证线程安全的原理是：内部使用了**ReentrantLock来保证线程安全，换言之就是使用AQS保证的线程安全**。同时`vector扩容是原来的两倍`，跟ArrayList不同。

#### 1.1.2 HashMap & ConcurrentHashMap

* Hash表，是一个时间复杂度为O(1)的数据结构，在等值查找的过程中具有特别大的优势。在jdk 1.7版本中，HashMap内部结构是**Hash表 + 链表**组成的，也就是俗称的`拉链法`。在jdk1.7中，一个hashMap默认的大小为**16**，扩容负载因子为**0.75**（**`引发问题1：扩容负载因子为什么是0.75`**），即当集合中的元素大于阈值**16 * 0.75 = 12**时，将要进行扩容，扩容为当前长度的**2倍**，此时因为jdk1.7在put元素采用的是头插法，这就导致如果在扩容的那一瞬间有多个请求同时对hashMap进行扩容，此时就会出现**环**的情况，即出现死循环（**`引发问题2：描述生成环的细节？`**）。在扩容的过程中，需要对原来的hashMap中的数组中的元素进行**rehash**，因为使用hash会出现hash碰撞的问题，jdk的作者为了将数据均匀分布在hash表中，特意设计了一个hash算法: 调用key的hashCode（**`引发问题3：为什么重写了HashCode后还要重写equals方法？`**）方法做完一系列操作后得出一个hash值最后再与hashMap的默认长度减一(`16 - 1 = 15`)做&运算得出要放入新hash表中的下标。其中hashMap的长度也支持自定义，但是我们最好把它的长度设置成2的幂次方。因为(2的幂次方 - 1)得出的结果的二进制中低四位全为1，这样的话hash的结果完全取决于key的hash值，这就达到了hash均匀分布的效果。

* 在jdk1.8中，针对上述的高并发下会出现环、以及链表查询效率低的情况做了改进。首先的改进为：put元素的方式从头插法变成了尾插法，以及对链表的数据结构进行扩展。**当链表的长度大于8且数组的长度&gt;64**，才会转成红黑树（**`引发问题4：为什么使用红黑树？`**）。但是即使换成了尾插法，但是仍然不建议在高并发的情况下使用HashMap，就算避免了出现死循环的情况，但是仍然不可避免数据的线程安全。在高并发的情况下最好使用juc包下的ConcurrentHashMap。

* 在jdk1.7中，ConcurrentHashMap采用的是segment分段锁来保证线程安全的，为什么说segment是一个锁呢？因为它继承了ReentrantLock类，在ConcurrentHashMap中，数组中存储的是segment对象，而segment对象内部维护了一个叫HashEntry的数组，其实我们可以把HashEntry理解成hashMap中的hashEntry，内部的逻辑和hashMap类似。而在jdk1.8中，ConcurrentHashMap放弃了segment分段锁，选择了synchronized + cas的方式来保证线程安全（**`引发问题5：为什么1.6之后改用成synchronized关键字保证线程安全？`**）。

  > 1. **`引发问题1：扩容负载因子为什么是0.75`**
  >
  > 2. **`引发问题2：描述生成环的细节？`**
  >
  >    ![hashMap1.7高并发变成环.png](hashMap1.7高并发变成环.png)
  >
  > 3. **`引发问题3：为什么重写了HashCode后还要重写equals方法？`**
  >
  >    这里拿hashMap做个例子，在hashMap中，是基于key的hashCode的值做了一些处理得出了index，但是hashCode是一个hash算法，难免会出现hash碰撞的情况。当出现hash碰撞后，得到的都是同样的下标，那么我们要如何来区分现在存在index的元素和我现在正在要put的元素是否相等呢？没错，就是使用equals方法来判断。hashcode只能说明当前对象的hashcode值，并不能代表对象相同。
  >
  > 4. **`引发问题4：为什么使用红黑树？`**
  >
  >    因为hashMap作为一个优秀的集合，会有频繁的插入和查找的特性，插入效率最好的是链表，而对于链表的进化数据结构而言查询效率比较好的完全平衡二叉树，而红黑树就位于这两者之间
  >
  > 5. **`引发问题5：为什么1.6之后改用成synchronized关键字保证线程安全？`**
  >
  >    因为jdk在1.6之后对synchronized关键字做了优化，它有一个锁升级的过程

* 更多关于hashMap的八股文，详见[此文章（点击查看）](https://mp.weixin.qq.com/s/7I-5RL0Py-g8mP7lJol3Yg)

### 1.2 创建对象的几种方式

* new、反射、反序列化、clone、使用unsafe类

### 1.3 深拷贝与浅拷贝

* **浅拷贝：**创建一个新对象，然后将当前对象的非静态字段复制到该新对象，如果字段是值类型的，那么对该字段执行赋值；如果该字段是引用类型的话，则复制引用但不复制引用的对象。因此，**原始对象及其副本引用同一个对象**。
* **深拷贝：**创建一个新对象，然后将当前对象的非静态字段复制到该新对象，无论该字段是值类型的还是引用类型，都复制独立的一份。当你修改其中一个对象的任何内容时，都不会影响另一个对象的内容。
* **总结：**深拷贝中，两个对象互相独立，毫无任何关系。浅拷贝中，引用对象拷贝的是引用，指向的还是堆内相同的对象。

### 1.4 并发相关

#### 1.4.1 有哪些锁的种类

| 锁种类   | 特性                                                         |
| -------- | ------------------------------------------------------------ |
| 悲观锁   | 悲观锁的特点是认为无时无刻都会出现并发的情况，所以每次都会加锁 |
| 乐观锁   | 乐观锁的特点是认为每次执行的过程中都不会出现并发的情况       |
| 可重入锁 | 锁的可重入性，即获取到锁的线程可以再次进入相同锁锁住的同步代码 |
| 自旋锁   | 所谓自旋锁就是让一个线程空转，jdk中使用for(;;)的语法。其实就是个死循环，当拿到锁后再跳出循环 |
| 轻量锁   | 多个线程交替执行，比如synchronized关键字的轻量锁、reentrantLock的轻量锁。所谓轻量锁就是一个概念，一种情景：关键就在于多个线程交替执行。<br/>为什么说ReentrantLock也是个轻量锁呢？若有两个线程交替使用reentanctLock的lock方法，此时aqs队列都没初始化，仅仅是交替抢占state资源 |
| 偏向锁   | 所谓偏向锁就是这把锁只偏向于一个线程。在jvm中偏向锁的功能默认是延迟4s的，可以添加**-XX:BiasedLockingStartupDelay=0**jvm参数来设置延迟加载为0或者在创建锁对象之前延迟4s。其中使用**-XX:+PrintFlagsFinal**参数可以查看到jvm中对偏向锁功能默认延迟的时间 |
| 重量锁   | 重量级锁为在一个线程持有锁的过程中，另外一个线程也来申请获取锁了，此时存在资源的竞争情况。 |

#### 1.4.2 cas是什么

* 全称Compare And Swap，是一种乐观锁。主要原理为：**依赖硬件层面的原子性来实现并发操作**。假设要对一个变量的值由1改成5.那么在更改的过程中，会对a做比较，假设a的值不是1，那么则不会做任何操作。反之将它修改为5。其中比较和替换是原子性操作，也就是说在比较的过程中或者比较完准备赋值的步骤中不会出现其它线程来赋值的操作。但这会引发**`ABA`**问题，假设线程A把1改成了5，线程B又把5改成了3。线程C又把3改成了1。要解决这个问题可以使用拥有版本号的Atomic类，比如**AtomicStampedReference**类，为每个版本添加了时间戳，这样就能知道变量有没有被改过了

#### 1.4.3 synchronized原理

* 首先synchronized关键字有三种使用方式：添加到代码块、实例对象、类对象。添加到代码块（指定同步代码块，并指定一个锁对象）中锁住的是当前锁对象，添加到实例对象（在实例方法中添加synchronized关键字）中。锁住的是当前实例对象。添加到类对象中（在static方法中添加synchronized关键字），锁住的是当前的Class对象。其实现原理是：当jvm把java类编译成class字节码文件时，会为synchronized关键字修饰的代码块添加一个**monitorenter**和**monitorexit**指令，这个指令为jvm的一个规范，具体的功能由具体的虚拟机去实现(**eg: hotspot，jrockit, j9等等**)，在hotspot中，此指令在底层对应的是一个叫moniter的对象，内部维护了一个**wait_list和entry_list**(只有在这个队列中的线程才有资格竞争cpu资源)，当我们在调用锁对象的wait方法时，会将当前线程放入wait_list中去，当调用notify时，会从wait_list中随机找出一个线程放入entry_list中去，当调用notifyAll方法时，会将wait_list中所有的线程都放入到entry_list中，再由cpu来随机调度，因此它是一个**`非公平锁`**。同时，在jdk1.6之前，**monitorenter**和**monitorexit**指令在底层对应的实现就是调用os系统的函数(**mutex中的函数**)，因此它是一个重量级锁。而在jdk 1.6之后，jvm对synchronized关键字进行了优化，添加了**偏向锁、轻量锁、重量锁**。
  下面将从两个方面来介绍锁升级过程:
  1. 当一个对象是在jvm启动4s后创建的，此时这把锁是一个可偏向状态(是指这把锁是一个偏向锁，但是他没有具体的偏向具体的线程)。当只有一个线程来对持有锁时，这时这个锁会具体的偏向于一个线程(**在偏向锁时，只会调用一次操作系统函数，后续在获取锁的过程中，jvm若发现当前锁是一把偏向锁并且偏向是同一个线程，那么此时就直接获取锁，不需要再调用操作系统函数，这也说明synchronized是一把`重入锁`**)。当有第二个线程来获取锁时，此时它会升级为轻量锁，若有多个线程竞争锁激烈，那么jvm会将锁升级成重量级锁。同时在偏向锁功能生效的情况下， 若一个可偏向状态的锁调用了它的hashcode方法，此时第一个线程去获取锁时，它不再是偏向锁，而是升级为轻量锁了。因为偏向锁和hashcode是互斥的，因为他们两都是使用对象头的同一块区域存储信息的。
  2. 当一个对象是在jvm启动后前4s创建的，此时它是处于无锁状态。当只有一个线程持有锁或者多个线程交替执行时，这把锁为轻量锁。在轻量锁当中，锁会做自动释放的操作，也就是轻量锁在获取锁和释放锁的过程中都会调用操作系统的函数。若线程不是交替执行，而是有激烈的竞争行为时，此时会膨胀成重量级锁，此时的锁就是一把重量级锁。同时synchronized关键字还具有`重偏向`和`重轻量`的特性。
     所谓`重偏向`是指同一个类型的锁升级轻量锁的次数达到了**20**，那么就会**将后面相同类型的锁批量重偏向于当前线程**。
     所谓`重轻量`是指同一个类型的锁升级轻量锁的次数达到了**40**，那么就会**将后面相同类型的锁批量升级为轻量锁**。

## 二、Dubbo

### 2.1 Dubbo支持哪些协议，每种协议的应用场景是什么，优缺点？

* Dubbo：单一长连接NIO异步通讯，适合**大并发小数据量**的服务调用，以及消费者远大于提供者的情况。
* rmi：采用JDK标准的rmi协议实现，传输参数和返回参数对象需要实现Serializable接口，使用java标准序列化机制，使用阻塞式短链接，传输数据包大小混合，消费者和提供者个数差不多，可传文件。
* webservice：基于WebService的远程调用协议，提供和原生WebService的操作。多个短链接，基于HTTP传输，同步传输，**适用于跨语言调用**
* http：基于http表单提交的远程调用协议，使用Spring的HttpInvoke实现。多个短连接，**提供者个数多于消费者**额情况使用
* memcache：
* redis：
* hessian：

### 2.2 Dubbo的超时时间怎样设置？

* Dubbo的超时时间有两种设置方式，第一种是在服务提供者设置超时时间，另外是在服务消费者设置超时时间，当两者都设置超时时间的话，以消费者的为准。

### 2.3 Dubbo支持哪些注册中心

* Multicast注册中心：基于广播的机制。基于网络中组播传输实现。
* Zookeeper注册中心：基于分布式协调系统Zookeeper实现，采用Zookeeper的watch机制实现数据变更。
* redis注册中心：基于redis实现，采用map的数据结构存储，主key存储服务名和类型，内部每一个对象中key存储的服务URL，value为服务的过期时间。基于redis的发布/订阅模式通知数据变更

### 2.4 Dubbo集群的负载均衡策略有哪些

* 随机、轮询、一致性hash、最少活跃调用。
* 随机：随机选一台服务提供者
* 轮询：依次轮询每一个服务提供者
* 一致性hash：同样的ip请求在同一个服务提供者中
* 最少活跃：每次请求时，筛选出被调用次数最少的节点。

### 2.5 Dubbo是什么

* Dubbo是一个分布式、高性能的RPC框架，提供服务自动注册、自动发现等高效服务治理方案，可以和Spring无缝集成

### 2.6 Dubbo的主要应用场景

* 服务自动注册与发现，不再需要写死服务提供方地址，注册中心基于接口名查询服务提供者的IP地址，并且能够平滑添加或删除服务提供者。

### 2.7 Dubbo的核心功能

* Remoting：网络通讯框架，提供对多种NIO框架抽象封装，包括“同步转异步”和“请求-响应”模式的信息交换方式
* Cluster：服务框架，提供基于接口方法的透明远程调用，包括多协议支持，以及软负载均衡，失败荣作，地址路由，动态配置等集群支持
* Registry：服务注册，基于注册中心目录服务，使服务消费方能动态的查找服务提供方，使地址透明，使服务提供方可以平滑增加或减少机器。

### 2.8 Dubbo的核心组件

* Provider：服务暴露者
* Consumer：服务消费者
* Registry：服务注册于发现的注册中心
* Monitor：统计服务的调用次数和调用时间的监控
* Container：服务运行容器

### 2.9 Dubbo服务注册与发现的流程

* 1、服务提供者绑定指定端口并启动服务

* 2、提供者连接注册中心，并将本地IP、端口、应用信息和提供服务信息发送至注册中心存储

* 3、消费者连接注册中心，斌发送应用信息、所求服务信息至注册中心

* 4、注册中心根据消费者所有服务信息匹配对应的提供者列表发送至服务提供者应用缓存

* 5、服务消费者在发起远程调用时基于缓存的消费者列表使用负载均衡策略选择一台服务提供者发起调用。

* 6、服务提供者状态变更会实时通知注册中心、在由注册中心实时推送至消费者，更新消费者本地缓存的服务提供者信息

* 这么设计的原因

  ```txt
  1、服务消费者与提供者解耦，双方都可以横向增减节点数
  2、注册中心本身可以做集群，可动态增减节点，并且任意一台宕机后，将自动切换到另一台
  3、去中心化：双方不直接依赖注册中心，即使注册中心全部宕机，短时间内也不会影响服务的调用（因为本机有对服务提供者的缓存）
  4、服务提供者无状态，任意一台宕机，不影响使用
  ```

### 2.10 Dubbo的架构设计

Dubbo一共划分为10层

* 服务接口层：位于最上面一层，也是我们接触最多的一层，消费者和提供者都位于这一层
* 配置层：对外配置接口，以ServiceConfig和ReferenceConfig为中心。一个是服务暴露相关的配置，一个是服务引用的相关配置
* 服务代理层：服务接口透明代理，生成服务的客户端
* 服务注册层：封装服务地址的注册于发现，以服务URL为中心
* 集群层：封装多个提供者的路由及负载均衡，并桥接注册中心，以Invoker为中心
* 监控层：RPC调用次数的调用时间和监控
* 远程调用层：封装RPC调用，以Invocation和Result为中心，扩展接口为Protocol、Invoker和Exporter
* 信息交换层：封装请求响应模式、同步转异步，以Request和Response为中心
* 网络传输层：抽象mina和netty为统一接口，以Message为中心

这里说它分为10层，我倒觉得可以分为如下几大模块：1、服务接口模块。2、配置模块  3、注册中心模块 4、集群模块 5、监控模块 6、远程调用模块



### 2.11 Dubbo有哪些容错机制

* **Failover Cluster**（默认）：失败自动切换，当失败后尝试调用其他服务提供者
* Failfast Cluster：快速失败，失败即抛异常
* Failsafe Cluster：失败安全，出现异常时，直接忽略。
* Failback Cluster：失败自动回复，后台记录失败请求，定时重发
* Forking Cluster：并行调用多个服务器，只要一个成功即返回。
* Broadcase Cluster：广播所有的提供者，逐个调用，任意一台报错则报错。通常用于通知所有提供者更新缓存或日志等本地资源信息。

### 2.12 Dubbo支持哪些序列化方式

* 默认使用Hessian序列化，还有FastJson、java自带的序列化

### 2.13 Dubbo调用超时问题怎么解决

* 首先Dubbo调用超时，仅仅是断开了连接，但服务提供者的执行流程依然在执行中。在默认的情况下，Dubbo在调用服务不成功时，默认是会重试两次的

### 2.14 Dubbo如何实现优雅的停机

* 

### 2.15 注册了多个同样的服务，如何测试指定的某一个服务？

* 可以配置点对点直连，绕过注册中心。

### 2.16 当一个服务接口有多种实现时怎么做？

* 可以添加Group来分组，服务提供者和消费者位于同一个Group即可。也可以添加verison，消费者指定要调用哪一个版本的服务即可

### 2.17  Dubbo服务之间的调用时阻塞的吗？

* 默认是同步等待结果阻塞，支持异步调用。如果是异步调用的话，最终会返回一个Future。

### 2.18 Dubbo如何优雅停机

* Dubbo是通过JDK的shutdownHook来完成优雅停机的，所以如果使用kill -9 命令强制关闭进程的话，是不会优雅关机的，只有通过kill命令才能实现优雅关机。而Dubbo底层在shutdownHook的回调中，肯定会校验当前服务的所有提供者是否还正在执行，以及内部是否还有线程在运行。等到这些操作都停止后，才会将应用下线。

### 2.19 服务提供者能实现失效提出的原理是什么？

* 依赖于Zookeeper的临时节点原理，当zookeeper ping不通服务提供者时，这时会将它踢下线，并将节点删除，同时广播给所有的服务消费者，告知它们这个节点下线了。

### 2.20 服务读写推荐的容错策略是怎样的

* 读操作建议使用Failover失败自动切换策略，默认重试两次其他提供者
* 写操作建议使用Failfast快速失败策略，调用失败则立即报错 

### 2.21 Dubbo的控制台能做什么

* 路由规则、动态配置、服务降级、访问控制、权重调整、负载均衡等管理

### 2.22 Dubbo的服务暴露流程

* Dubbo会在Spring实例化完bean之后，在刷新容器最后一步发布ContextRefreshEvent事件的时候，由ServiceBean内部来监听这个事件，进而触发export方法，完成服务暴露的流程

### 2.23 在使用Dubbo的过程中有遇到哪些问题？

* 一个协议用到底，因为默认推荐的是Dubbo协议，因此在很多传输大文件的过程中会影响并发量，实际上这个时候应该用Http协议比较好。其次，在使用泛化调用时，RefrenceBean对象比较大，在并发的情况下，出现了OOM的情况。公司开发的负载均衡使用情况

### 2.24 Dubbo启动时，如果依赖的服务不可用会怎么样

* Dubbo缺省会启动检查依赖服务是否可用，不可用会抛出异常，可以通过check为false来关闭这个功能。

## 三、网络相关

### 3.1、说说你在浏览器中请求应用服务器的一张图片时，浏览器做了哪些事、网络做了哪些事、操作系统做了哪些事？

* 这里面涉及到了网络的OSI七层协议，但是我们主要看5层就行了。首先，我们的应用都是位于应用层的，如果应用层要有任何交互数据时，会做一个甩手掌柜，直接将传输数据的工作交给传输层去做了。而传输层中大概率用的就是TCP/UDP协议来交互数据了，对于TCP而言，它有很多优点：控制流量、能确保对方收到了数据。而UDP则是不安全的，但是它可以支持海量请求。应用层发起的请求经过传输层后，传输层会对请求数据做一层封装，在头部添加了传输层相关的信息。而要想继续传递数据的话，此时就要依赖网络层了。在网络层中，基本上使用的就是ip协议和路由了。当一个请求到达网络层后，网络层需要知道，这个请求最终是请求到哪里去，因此，会使用到ip协议的一些特点。ip协议一共会分为两个大的部分，分别为：网络地址和主机地址。通常，会使用网络地址上的信息来确定这个请求最终会落入哪一个网点，而使用主机地址的话可以确定要请求到这个网点中的那一台机器。这对应的就是ip寻址和路由两个操作，ip寻址相当于提供了导航的功能，而路由则是我们的方向盘。因此，经过网络层后，我们是能知道这个请求要请求到哪个网点的哪个主机上了。但是我们的每台机器都不一定位于同一个网段，因此，会出现跨网调用的情况。而这个时候，就需要依赖与数据链路层了，在这一层中我们主要会依赖于路由器，在路由器中会存储ip和mac地址的映射，我们在网络层不是知道了要请求的ip在哪里了么，此时我们还要知道具体是哪一台电脑，而每台机器都有一个固定的mac地址，因此路由器有这么一个映射关系后，是能知道我们的请求最终要命中哪一台具体的电脑的。有了上面的应用层、传输层、网络层、数据链路层的工作之后，我们已经知道请求要落在那个电脑上了，因此，后面的步骤就是真正的传输的，因为网络中的传输都是以二进制为标准的，因此需要将我们的请求转化成二进制，而这么一个操作就是在物理层来实现的。这是一个请求的过程，而数据响应的过程也与这个类似。