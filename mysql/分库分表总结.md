# 一、为什么要分库分表

* 随着业务体量的上升，数据库里的数据会持续增加，最终可能会出现单表查询比较慢的情况（**通常是分页查询的场景，翻到越后面的页数，查询越慢**）。**又或者，因为单库的连接数有限，如果请求量较大时，会出现链接不够的情况**。这个时候可以把业务隔开，每种业务对应一个库，那业务之间就不会互相影响了。

## 1.1 什么时候建议分库分表？

* 阿里建议：预估三年内的数据量大于500w或单表数据文件大于2G，则需要进行分库分表操作。
  * 这个只是一个建议，具体还是要根据业务和mysql服务器的性能来考虑。我之前做过的支付系统，支付流水有1亿+，还是单库单表的模式，也能支撑业务
* 数据增长：这个要根据业务来做评估，如果是交易类的数据，随着业务体谅的扩增，订单量务必会出现暴涨的情况，那这个时候就需要做分库分表操作，防止日后扩展到分库分表架构后，还要进行数据迁移工作。如果是新用户类的数据，那越到后面，数据就约平稳，这个时候可以考虑下用户量，看是否要做分库分表操作。
* 读多写少：由于频繁变更分片键，需要同时做数据迁移。对于分片键变更频繁的数据，不适合做分库分表操作。
  * 比如：如果一个业务的分片键是按照用户地址来做的话， 那每次用户修改地址，都需要涉及到数据的迁移。（修改用户地址其实也是比较低频的操作，这里只是为了举例）
* 预估业务的查询逻辑：业务逻辑与分片逻辑绑定，会给sql带来很多限制。如果对数据的查询逻辑变化非常大，通常也是不建议进行分库分表操作的。

# 二、分库分表的几种类型

## 2.1、分库

### 2.1.1、垂直分库

* 什么叫垂直分库？一句话总结：**按业务划分库，业务之间不会互相影响**。eg：用户域是一个库、会员域是一个库、商品域是一个库，用户和商品之间不会互相影响。常见于分布式微服务系统。

  ![垂直分库示例图](.\垂直分库示例图.jpg)

* 优点：业务解耦

* 缺点：还是会局限于某个库的某个表的数据量

### 2.1.2、水平分库
* 什么叫水平分库？一句话总结：**单库的数据量太大，连接数有限，需要分多个库来提高性能**。通常水平分库下，库里的每张表的结构都是一样的，只是把数据分摊到其他库里去了。

  ![水平分库示例图](.\水平分库示意图.png)

* 优点：单表数据量减少，提升性能

* 缺点：数据扩容难度大，如果要新增一个库的话，需要修改路由规则，同时还需要将数据重刷（eg：之前两个库，会根据userId对2取余做操来决定数据要落到哪个库中去。如果现在变成3个库了，那之前在1库的数据很有可能会落到第二个库中去，因此，这里需要做数据重刷操作）

## 2.2、分表
### 2.2.1、垂直分表
* 一句话总结：**垂直分表就是将某些不常用的、存储信息比较大的字段放在另外一张表，减少了mysql内存加载数据的大小以及网络传输的**。

* eg：用户信息表，在用户登录业务中可能只会用到用户名称和密码，但是像收货地址、身份证、性别这种在登录业务中很少用，因此这里就可以把用户信息表分成user_base和user_info表。如果要更新用户的详情信息时，再操作user_info表。

* 示例：

  ![垂直分表示意图](.\垂直分表.jpg)

* 特点：
  * 每张表的结构是不一样的。比如user_base表和user_info表
  * 两张表至少有一列的字段和值是一样的
  * 两张表并起来就是当前业务的全量数据

### 2.2.2、水平分表

* 一句话总结：**一张表存储的数据量有限，需要用多张表来存储数据**。

* 示例

  ![水平分表示意图](.\水平分表.jpg)

* 特点：
  * 水平分表后的每张表数据结构一模一样
  * 多张表并起来就是全量数据

> 所谓的垂直和水平，就看表是怎么被切割的。垂直分表是将一行的数据，分别存在不同的表中。水平分表，是将不同行的数据存在不同的表中。

# 三、分库分表带来的问题

## 3.1、主键唯一性问题

* 分库分表后，我们不能再使用数据库递增的id来作为业务的唯一主键了。此时我们得选择一种分布式唯一id来作为业务的唯一键。
  * 通常，我们会很自然的想到使用uuid来作为唯一主键。但使用uuid作为分库分表的业务唯一键有如下几个缺点：
    * 每次插入一个条数据时，索引重建耗时比自增唯一键耗时长（之前是数据库的自增唯一键，就是一个bigint类别，重现b+树比较快。现在是uuid，是一个比较长的字符串，在排序的时候，肯定没有bigint效率高。）
* 那我们在分库分表情况下，该如何来选择业务的唯一键呢？它必须包含如下特点：
  * id是数字类别（在重建索引和利用索引检索数据时，排序效率比字符串高）
  * 是单调递增的（在重建索引时，能更快的找到它的位置，通常是排在B+树最后面。）

## 3.2、分布式事务

* 在单库单表时，我们在做一个完整业务时（比如下单业务需要创建订单和扣减库存这两个操作一起完成），可以直接利用mysql的事务管理机制。但在分库分表情况下（出现分库的情况），我们需要保证分布式情况下的事务问题。
* 通常会有如下解决方案：
  * 最终一致性方案：
  * 两阶段模式：
  * 三阶段模式：
  * seta的at模式：

## 3.3、SQL路由

* 当数据分到不同的片之后，我们查询也会变得复杂，需要进行路由（比如用户A的数据1表，用户B的数据在2表，那在展示用户信息时，需要知道用户A的数据去1表查询），比如我需要知道数据在数据库中存不存在，如果没有路由的话，我需要到每个分片中去查一遍，这样的效果很低。再比如想查询id in (1,2,3,4,5)的用户数据，这个时候也需要进行路由才能知道要去哪些分片中获取数据。

## 3.4、结果归并

* 比如现在要查询支付金额最高的10个订单，在分布式情况下，我们需要去所有的分片中查询订单金额最高的十个订单，再把返回的数据在内存做一次排序，才能获取真正金额最高的10个订单。
* 



# 四、分库分表中间件

* 分库分表中间件通常分位两种类别：
  * **jdbc直连**：举例 shardingsphere、tddl
  * **代理**：举例 mycat、mysqlproxy
* 通常情况下，jdbc直连的方式扩展性比较高。

## 4.1、jdbc直连工作原理
* 远程mysql服务器是多台，java应用以jar包的方式依赖，在客户端做操作，根据分片规则决定请求到mysql的哪台服务器的哪个库里。

* 以shardingsphere为例，它的原理是：

  ![shardingsphare](.\shardingsphare.jpg)

## 4.2、proxy工作原理

* java应用和连mysql一样。直接链接到代理机器，由代理机器做后续的路由操作。